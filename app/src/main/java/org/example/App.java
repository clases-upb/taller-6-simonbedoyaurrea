/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example;
import java.text.DecimalFormat;
import java.util.Scanner;
import java.io.*;

public class App {

    public static void main(String[] args) {
        try {
            //vector para calcular_temperaturas
            double[] vector_tempe=new double[6];
            
            //la ruta del archivo pueede cambiar
         System.out.println(Ordenar_vector_archivo("src/main/palabras.txt"));
            
         System.out.println(Convertir_decimal_hexadecimal( 3609));
        System.out.println(Calcular_producto_division_diagonales());
        System.out.println(Hallar_matriz_transpuesta(5));
        System.out.println(Llenar_matriz_aleatoria_con_X_O());
        System.out.println(Calcular_temperaturas(vector_tempe));
         System.out.println(Calcular_repetidos_matriz_vector());

            //usan scanner
            System.out.println(Eliminar_posicion_vector(8));
            //menu punto 1
             Scanner sc = new Scanner(System.in);
          String option="";
          String subopcion="";
          String[] subvector=new String[2];
          do {
              System.out.println("\nMenu:");
              System.out.println("1. Llenar Vectores");
              System.out.println("2. Recorrer Vector");
              System.out.println("3. Actualizar Elemento en el vector de cadenas");
              System.out.println("4. Actualizar Elemento en el vector de enteros");
              System.out.println("5. ordenar vector de cadenas");
              System.out.println("6. Ordenar Vector de enteros");
              System.out.println("7. Buscar Elemento en vector de cadenas");
              System.out.println("8. Buscar Elemento en vector de enteros");
              System.out.println("9. Salir");
              System.out.print("Seleccione una opción: ");
              option = sc.next();

              switch (option.charAt(0)) {
                  case '1':
                      System.out.println(Insertar_elementos());
                      break;
                 case '2':
                        System.out.println("ponga t para recorrer de principio a fin y f para recorrer de fin a principio,añada la posicion final ej:t4");
                      subopcion=sc.next();
                        switch(subopcion.charAt(0)){
                            case 't':
                            System.out.println(Recorrer_secuencialmente(true,Integer.parseInt(subopcion.substring(1))));
                                break;
                            case 'f':
                            System.out.println(Recorrer_secuencialmente(false,Integer.parseInt(subopcion.substring(1))));
                                break;
                            default:
                                System.out.println("opcion incorrecta");
                                break;
                        }
                             break;
                  case '3':
                      System.out.println("ponga la posicion y la cadena a actualizar separado de una coma ej:3,hola");
                      subopcion=sc.next();
                      subvector=subopcion.split(",");
                      
                      System.out.println(Actualizar_vector_string(Integer.parseInt(subvector[0]),subvector[1]));
                          break;
                  case '4': System.out.println("ponga la posicion y el entero nuevo a actualizar separado de una coma ej:3,5");
                        subopcion=sc.next();
                        subvector=subopcion.split(",");

                        System.out.println(Actualizar_vector_entero(Integer.parseInt(subvector[0]),Integer.parseInt(subvector[1])));
                      break;
                      
                  case '5':
                      System.out.println("ponga t para ascendente y f para descendente");
                        subopcion=sc.next();
                        switch(subopcion.charAt(0)){
                            case 't':
                                System.out.println(Ordenar_asc_desc_string(true));
                                break;
                            case 'f':
                                System.out.println(Ordenar_asc_desc_string(false));

                                break;
                        }
                      break;
                  case '6':
                      System.out.println("ponga t para ascendente y f para descendente");
                      subopcion=sc.next();
                      switch(subopcion.charAt(0)){
                          case 't':
                              System.out.println(Ordenar_asc_desc_enteros(true));
                              break;
                          case 'f':
                              System.out.println(Ordenar_asc_desc_enteros(false));

                              break;
                      }
                      break;
                  case '7':
                      System.out.println("ponga la cadena que quiere buscar");
                        subopcion=sc.next();

                      System.out.println(Busqueda_elemento_cadena(subopcion));
                      break;
                  case '8':
                      System.out.println("ponga el entero que quiere buscar");
                          subopcion=sc.next();
                    System.out.println(Busqueda_elemento_entero(Integer.parseInt(subopcion)));
                      break;
                      
                  default:
                      System.out.println("Opción inválida. Intente nuevamente.");
                      break;
                 
              }
          } while (option.charAt(0) != 8);
      

        } catch (Exception e) {
           System.out.println("error en el main"+e);
        }
    }

    /*
     * 1. Implemente un programa en java donde inserte elementos en dos vectores
     * globales de tamaños aleatorios y de contenido aleatorio (uno numérico y otro
     * de Strings). Considere dejar espacios libres en los vectores.
     * 
     * Desde un menú en el programa principal debe considerar cada opción para
     * llamar las siguientes funciones que también debe programar:
     * 
     * a. Recorrer secuencialmente (recibe un true cuando va del primero al último y
     * un false cuando va del último al primero)
     * • De primer elemento a último elemento: Imprime desde el primer elemento
     * hasta el último del vector dado en el parámetro de entrada.
     * • De último elemento al primer elemento: Imprime desde el último elemento
     * hasta el primero del vector dado en el parámetro de entrada.
     * 
     * b. Actualizar: recibe la posición que va a actualizar y el elemento. Al final
     * imprime el vector actualizado.
     * 
     * c. Añadir: después del último: recibe el elemento que va a añadir. Al final
     * imprime el vector actualizado.
     * 
     * d. Borrar: Recibe la posición donde del elemento que va a borrar.
     * 
     * e. Ordenar el vector:
     * • Ascendentemente.
     * • Descendentemente.
     * 
     * f. Búsqueda: Recibe como parámetro el elemento a buscar y devuelve un String
     * separado por el carácter '-', mostrando las posiciones donde se encuentra el
     * elemento.
     */
     public static String Insertar_elementos(){
          
          try {
                int letra1=0,letra2=0,letra3=0;
              int tamanio_vector=(int)(Math.random()*(15-5+1)+5);
                char car1,car2,car3;
                String txt_retornar="";

              vector_enteros_punto1=new int[tamanio_vector];
              vector_strings_punto1=new String[tamanio_vector];

              
             for(int pos=0;pos<vector_enteros_punto1.length;pos++){
                 vector_enteros_punto1[pos]=(int)(Math.random()*(12-1+1)+1);
                 
                 letra1=(int)(Math.random()*(122-97+1)+97);
                 letra2=(int)(Math.random()*(122-97+1)+97);
                 letra3=(int)(Math.random()*(122-97+1)+97);
                 car1=(char)letra1;
                 car2=(char)letra2;
                 car3=(char)letra3;
                 vector_strings_punto1[pos]=""+car1+""+car2+""+car3;
             }
              for(int pos=0;pos<vector_enteros_punto1.length;pos++){
                  txt_retornar+=vector_enteros_punto1[pos]+"-";
              }
              txt_retornar+="\n";
              
              for(int pos=0;pos<vector_strings_punto1.length;pos++){
                    txt_retornar+=vector_strings_punto1[pos]+"-";
                }

              return txt_retornar;
              
              
          }
          catch (Exception e) {
              return "Error en la función Insertar_elementos";
          }
          
      }
        
      public static String Recorrer_secuencialmente(boolean sentido,int posicion_final){
          try {
              String txt_retornar="";
              
              
                if(sentido){
                    for(int pos=0;pos<=posicion_final;pos++){
                        txt_retornar+=vector_enteros_punto1[pos]+"-";
                    }
                    txt_retornar+="\n";
                    
                    for(int pos=0;pos<=posicion_final;pos++){
                        txt_retornar+=vector_strings_punto1[pos]+"-";
                    }
                    
                }else{
                    for(int pos=(vector_strings_punto1.length-1);pos>=posicion_final;pos--){
                        txt_retornar+=vector_enteros_punto1[pos]+"-";
                    }
                    txt_retornar+="\n";

                    for(int pos=(vector_strings_punto1.length-1);pos>=posicion_final;pos--){
                        txt_retornar+=vector_strings_punto1[pos]+"-";
                    }
                }
              return txt_retornar;


            }
            catch (Exception e) {
                return "Error en la función Recorrer_secuencialmente";
            }
       }
      public static String Actualizar_vector_string(int posicion, String elemento){
          try {
                String txt_retornar="";
                vector_strings_punto1[posicion]=elemento;
              for(int pos=0;pos<vector_strings_punto1.length;pos++){
                  txt_retornar+=vector_strings_punto1[pos]+"-";
              }
              return txt_retornar;
            }
            catch (Exception e) {
                return "Error en la función Actualizar_vector_string";
            }
      }
      public static String Actualizar_vector_entero(int posicion, int elemento){
            try {    
                      String txt_retornar="";
                      vector_enteros_punto1[posicion]=elemento;
                    for(int pos=0;pos<vector_enteros_punto1.length;pos++){
                          txt_retornar+=vector_enteros_punto1[pos]+"-";
                      }
                
                      return txt_retornar;
                

              }
              catch (Exception e) {
                  return "Error en la función Actuaizar_vector_entero";
              }
        }
        
    public static String Ordenar_asc_desc_enteros(boolean sentido){
           try {
               String vector_ordenado_ascendente="",vector_ordenado_descendente="";
              int vec_aux=0;
              if(sentido){
                  for(int pos=0;pos<vector_enteros_punto1.length;pos++){
                      for(int comparador=0;comparador<vector_enteros_punto1.length;comparador++){
                          if(vector_enteros_punto1[pos]<(vector_enteros_punto1[comparador])){
                              vec_aux=vector_enteros_punto1[pos];
                              vector_enteros_punto1[pos]=vector_enteros_punto1[comparador];
                              vector_enteros_punto1[comparador]=vec_aux;
                          }
                      }
                  }
                  for(int pos=0;pos<vector_enteros_punto1.length;pos++){
                      vector_ordenado_ascendente+=vector_enteros_punto1[pos]+"\n";   
                  }

                  return vector_ordenado_ascendente;
              }
              else{
                  for(int pos=0;pos<vector_enteros_punto1.length;pos++){
                      for(int comparador=0;comparador<vector_enteros_punto1.length;comparador++){
                          if(vector_enteros_punto1[pos]>vector_enteros_punto1[comparador]){
                              vec_aux=vector_enteros_punto1[pos];
                              vector_enteros_punto1[pos]=vector_enteros_punto1[comparador];
                              vector_enteros_punto1[comparador]=vec_aux;
                          }
                      }
                  }
                  for(int pos=0;pos<vector_enteros_punto1.length;pos++){
                      vector_ordenado_descendente+=vector_enteros_punto1[pos]+"\n";
                  }
                  return vector_ordenado_descendente;
              }
              
                

             


            }
            catch (Exception e) {
                return "Error en la función Insertar_elementos";
            }
      }
      
      public static String Ordenar_asc_desc_string(boolean sentido){
            try {
                  String vec_aux="";
                  String vector_ordenado_ascendente="",vector_ordenado_descendente="";
                    if(sentido){
                        for(int pos=0;pos<vector_strings_punto1.length;pos++){
                              for(int comparador=0;comparador<vector_strings_punto1.length;comparador++){
                                  if(vector_strings_punto1[pos].compareTo(vector_strings_punto1[comparador])>0){
                                      vec_aux=vector_strings_punto1[pos];
                                      vector_strings_punto1[pos]=vector_strings_punto1[comparador];
                                      vector_strings_punto1[comparador]=vec_aux;
                                  }
                              }
                          }
                          for(int pos=0;pos<vector_strings_punto1.length;pos++){
                              vector_ordenado_ascendente+=vector_strings_punto1[pos]+"\n";   
                          }
                        return vector_ordenado_ascendente;
                    }
                else{
                    for(int pos=0;pos<vector_strings_punto1.length;pos++){
                          for(int comparador=0;comparador<vector_strings_punto1.length;comparador++){
                              if(vector_strings_punto1[pos].compareTo(vector_strings_punto1[comparador])<0){
                                  vec_aux=vector_strings_punto1[pos];
                                  vector_strings_punto1[pos]=vector_strings_punto1[comparador];
                                  vector_strings_punto1[comparador]=vec_aux;
                              }
                          }
                      }
                      for(int pos=0;pos<vector_enteros_punto1.length;pos++){
                          vector_ordenado_descendente+=vector_strings_punto1[pos]+"\n";
                      }
                    return vector_ordenado_descendente;
                }

              }
              catch (Exception e) {
                  return "Error en la función Insertar_elementos";
              }
        }
      
       public static String Busqueda_elemento_cadena(String elemento){
          try {
              String txt_retornar="coincidencias: \n";
              for(int pos=0;pos<vector_strings_punto1.length;pos++){
                  if(vector_strings_punto1[pos].compareTo(elemento)==0){
                      txt_retornar+=pos+"-";
                  }
              }
              return txt_retornar;
            }
            catch (Exception e) {
                return "Error en la función Busqueda_elementos_cadena";
            }
       }
      
      public static String Busqueda_elemento_entero(int elemento){
            try {
                String txt_retornar="coincidencias: \n";
                  for(int pos=0;pos<vector_enteros_punto1.length;pos++){
                      if(vector_enteros_punto1[pos]==elemento){
                          txt_retornar+=pos+"-";
                      }
                  }
                  return txt_retornar;
              }
              catch (Exception e) {
                  return "Error en la función Busqueda_elementos_entero";
              }
         }

    /*
     * 2. Escriba un algoritmo que calcule aleatoriamente N temperaturas, las lleve
     * a un vector y luego calcule su media, cuántas temperaturas están por encima
     * de la media y cuántas por debajo.
     */
     public static String Calcular_temperaturas(double vector[]){
            try {
                String txt_retornar="";
                double max_temp=40.0;
                double min_temp=20.0;
                DecimalFormat df = new DecimalFormat("#.00");
                double media=0;
                double suma_temp=0;
                int temp_abajo=0;
                int temp_encima=0;
                
                
                 for(int pos=0;pos<vector.length;pos++){
                     vector[pos]=(Math.random()*(max_temp-min_temp+1)+min_temp);
                      suma_temp+=vector[pos];
               }
                media=suma_temp/vector.length;

                for(int pos=0;pos<vector.length;pos++){
                    if(vector[pos]>media){
                        temp_encima++;
                    }else{
                        temp_abajo++;
                    }
                }
                txt_retornar="La media de las temperturas es "+df.format(media)+ " y hay "+temp_encima+" temperaturas por encima de la media y "+temp_abajo+" temperaturas por debajo de la media";
                
                    return txt_retornar;
              }
              catch (Exception e) {
                return "error en Calcular_temperaturas";
              }
          
          
      }

    /*
     * 3. Cargue un vector a partir de un archivo de palabras, con mínimo 10
     * palabras. Ordene el vector de manera ascendente y luego de forma descendente.
     * 
     * Escriba el vector inicial sin ordenar, los vectores ordenados.
     */
     public static String Ordenar_vector_archivo(String ruta){
        try {
                String[] vector=new String[10];
                String txt_retornar="",vector_normal="",vector_ordenado_descendente="",vector_ordenado_ascendente=""; 
                String linea=null;
                File archivo =new File(ruta);
                FileReader fl= new FileReader(archivo);
                BufferedReader br= new BufferedReader(fl);
                int pos_arch=0;
                String vec_aux="";
            
                linea=br.readLine();

                while(linea !=null){
                    vector[pos_arch]=linea;
                    pos_arch++;
                    linea=br.readLine();
                }

               br.close();

            for(int pos=0;pos<vector.length;pos++){
                vector_normal+=vector[pos]+"\n";
            }

            for(int pos=0;pos<vector.length;pos++){
                for(int comparador=0;comparador<vector.length;comparador++){
                    if(vector[pos].compareTo(vector[comparador])<0){
                        vec_aux=vector[pos];
                        vector[pos]=vector[comparador];
                        vector[comparador]=vec_aux;
                    }
                }
            }
            for(int pos=0;pos<vector.length;pos++){
                vector_ordenado_descendente+=vector[pos]+"\n";
            }

            for(int pos=0;pos<vector.length;pos++){
                for(int comparador=0;comparador<vector.length;comparador++){
                    if(vector[pos].compareTo(vector[comparador])>0){
                        vec_aux=vector[pos];
                        vector[pos]=vector[comparador];
                        vector[comparador]=vec_aux;
                    }
                }
            }
            for(int pos=0;pos<vector.length;pos++){
                vector_ordenado_ascendente+=vector[pos]+"\n";   
            }

                txt_retornar="El vector normal es \n "+vector_normal+"\n"+"El vector ordenado descendete es \n"+vector_ordenado_descendente+"\n"+"el vector ordenado ascendente es \n"+vector_ordenado_ascendente;
            
            return txt_retornar;
          }
        
          catch (Exception e) {
              return "error en Ordenar_vector_archivo";
          }

    }

    /*
     * 4. Escriba un algoritmo que cree un vector de N elementos (el N es dado por
     * el usuario) de números short aleatorios positivos mayores que cero, y luego
     * le pregunte al usuario qué posición quiere eliminar. Luego por un menú
     * presente las opciones: Dejar la casilla en 0 o desplazar los elementos de
     * manera que el cero quede en la última posición del vector. Después de la
     * operación mostrará el vector cómo va quedando y volverá a preguntar qué
     * posición quiere borrar y mostrará nuevamente el menú. En el menú aparecerá la
     * opción para terminar el programa.
     */
     public static String Eliminar_posicion_vector(int orden){
          try{
              short[] vector=new short[orden];
              int nro_max=100, nro_min=1;
              Scanner scanner=new Scanner(System.in);
              String opcion="";
              String txt_retornar="";
              int pos_eliminar=0;
              

              for(int pos=0;pos<vector.length;pos++){
                  vector[pos]=(short)(Math.random()*(nro_max-nro_min+1)+nro_min);
              }
              
              do {
                  System.out.println("ingrese una opcion");
                  System.out.println("1-Ingresar la posicion que desea eliminar");
                  System.out.println("2-salir");

                  opcion=scanner.next();
                  
                  switch (opcion.charAt(0)) {
                      case '1':
                          System.out.println("ingrese la posicion que desea eliminar");
                          pos_eliminar=scanner.nextInt();
                          if(pos_eliminar<vector.length && pos_eliminar>=0){
                              
                              do{   System.out.println("¿que desea hacer con la posicion "+pos_eliminar+"?");
                                    System.out.println("4-dejar casilla en 0");
                                    System.out.println("5-desplazar elementos");
                                    System.out.println("6-salir");
                                    opcion=scanner.next();
                                  
                                    switch (opcion.charAt(0)) {
                                      case '4':
                                          System.out.println("ingresó opcion 4");
                                          vector[pos_eliminar]=0;
                                          for(int pos=0;pos<vector.length;pos++){
                                              txt_retornar+=vector[pos]+"\t";
                                          }
                                            System.out.println(txt_retornar);
                                            txt_retornar="";
                                          break;
                                      case '5':
                                            System.out.println("ingresó opcion 5");
                                            if(pos_eliminar==vector.length-1){
                                                vector[pos_eliminar]=0;
                                            }else{
                                                for(int pos=pos_eliminar;pos<vector.length-1;pos++){
                                                    vector[pos]=vector[pos+1];
                                                }
                                                vector[vector.length-1]=0;
                                            }
                                            for(int pos=0;pos<vector.length;pos++){
                                                  txt_retornar+=vector[pos]+"\t";
                                              }
                                            System.out.println(txt_retornar);
                                            txt_retornar="";
                                          break;
                                      case '6':
                                            break;
                                      default :
                                            System.out.println("opción no valida");
                                            break;
                                    }
                                  
                              }while(opcion.charAt(0)!='6');
                          }else{
                              System.out.println("la posicion ingresada no es valida");
                          }
                          break;
                      case '2':
                          for(int pos=0;pos<vector.length;pos++){
                                txt_retornar+=vector[pos]+"\t";
                            }
                          System.out.println("Finalizo,asi queda el vector: \n"+txt_retornar);
                          
                          break;
                      default:
                          System.out.println("opcion no valida");
                          break;
                  }

                  
                } while (opcion.charAt(0)!='2');
              
                return "finalizo";
            }
            catch (Exception e){
                return "error en Eliminar_posicion_vector";
                
            }
      }

    /*
     * 5. Escriba un algoritmo para convertir un número decimal en un número
     * hexadecimal, apoyado en vectores.
     */
     public static String Convertir_decimal_hexadecimal(int numero){
          try {
              String txt_retornar="";
              int numero_aux=numero;
              int tamanio_vector=0;
              while(numero_aux/16>0){
                  numero_aux=numero_aux/16;
                  tamanio_vector++;
              }
              String vector[]=new String[tamanio_vector+1];
              
              for(int pos=0;pos<vector.length;pos++){
                  vector[pos]=String.valueOf(numero%16);
                  numero=numero/16;
              }
              
              for(int pos=vector.length-1;pos>=0;pos--){
                  if(vector[pos].equals("10")){
                      vector[pos]="A";
                  }
                   else if(vector[pos].equals("11")){
                        vector[pos]="B";
                  }
                   else if (vector[pos].equals("12")){
                        vector[pos]="C";
                    }
                   else if(vector[pos].equals("13")){
                        vector[pos]="D";
                    }
                   else if(vector[pos].equals("14")){
                        vector[pos]="E";
                    }
                   else if(vector[pos].equals("15")){
                        vector[pos]="F";
                    }
                  txt_retornar+=vector[pos];
                   
                }
              
             return txt_retornar;
            }
            catch (Exception e) {
              return "error en Convertir_decimal_hexadecimal";
            }
          
      }

    /*
     * 6. Escriba un algoritmo que solicite al usuario el orden de una matriz
     * cuadrática, implemente su matriz transpuesta (investiga qué es) y la imprima.
     */
      public static String Hallar_matriz_transpuesta(int orden){
          try {
              int[][] matriz_principal=new int[orden][orden];
              int[][] matriz_transpuesta=new int[orden][orden];
              String txt_retornar="",matriz_principal_impresa="",matriz_transpuesta_impresa="";

              for (int i = 0; i < matriz_principal.length; i++) {
                     for (int j = 0; j < matriz_principal.length; j++) {
                         matriz_principal[i][j]=(int)(Math.random()*(9-1+1)+1);
                     }
                 }

              
               for (int i = 0; i < matriz_principal.length; i++) {
                   for (int j = 0; j < matriz_principal.length; j++) {
                       matriz_transpuesta[j][i] = matriz_principal[i][j];
                   }
               }
              for (int i = 0; i < matriz_principal.length; i++) {
                     for (int j = 0; j < matriz_principal.length; j++) {
                         matriz_principal_impresa+=matriz_principal[i][j]+"\t";
                         matriz_transpuesta_impresa+=matriz_transpuesta[i][j]+"\t";
                     }
                     matriz_principal_impresa+="\n";
                     matriz_transpuesta_impresa+="\n";
                 }

              txt_retornar="la matriz principal es \n"+matriz_principal_impresa+"\n"+"la matriz transpuesta es \n"+matriz_transpuesta_impresa;

              return txt_retornar;

            }
            catch (Exception e) {
                return "error en Hallar_matriz_transpuesta";
            }
      }

    /*
     * 7. Escriba un algoritmo que calcule el producto y la división. Los operandos
     * serán la suma de elementos de la diagonal principal y la suma de los
     * elementos de la diagonal secundaria. Los elementos de la matriz deben ser
     * llenados usando la función random para calcular números aleatorios entre 10 y
     * 100.
     */
 public static String  Calcular_producto_division_diagonales(){
          try {
               String txt_retornar="";
               int suma_diagonal_principal=0;
               int suma_diagonal_secundaria=0;
               int orden=(int)(Math.random()*(10-2+1)+2);
               int matriz[][]=new int[orden][orden];
               int producto=0;
               double division=0;
              String matriz_impresa="";

              for(int fila=0;fila<matriz.length;fila++){
                  for(int col=0;col<matriz[0].length;col++){
                      matriz[fila][col]=(int)(Math.random()*(100-10+1)+10);
                  }
              }
              
              for(int pos=0;pos<matriz.length;pos++){
                    suma_diagonal_principal+=matriz[pos][pos];
                }
              
              int columna=matriz.length-1;
              for(int fila=0;fila<matriz.length;fila++){
                    suma_diagonal_secundaria+=matriz[fila][columna];
                    columna--;
                }
              producto=suma_diagonal_principal*suma_diagonal_secundaria;
              division=suma_diagonal_principal/suma_diagonal_secundaria;

              for(int fila=0;fila<matriz.length;fila++){
                    for(int col=0;col<matriz[0].length;col++){
                       matriz_impresa+=matriz[fila][col]+" ";
                    }
                  matriz_impresa+="\n";
                }

              txt_retornar="El producto de las diagoanales es "+producto+" y la division es "+division+"\n"+ "La matriz es \n"+matriz_impresa;
              return txt_retornar;
                    
              }
              catch (Exception e) {
                return "error en Calcular_producto_division_diagonales";
              }
      }
    /*
     * 8. Escriba un algoritmo que llene de manera aleatoria una matriz de 100 filas
     * por 3 columnas con Xs y Os. Y mediante un vector cuente el número de Xs y Os
     * en cada fila. Imprima la matriz antes de llenarla, luego de llenarla y el
     * vector con el resultado.
     */

    public static String  Llenar_matriz_aleatoria_con_X_O(){
          try{
                int orden_filas =100;
                int orden_columnas=3;
                String txt_retornar="";
                int[] vector_x=new int[orden_filas];
                String vector_x_impreso="",vector_o_impreso="";
              
                int[] vector_o=new int[orden_filas];
                String matriz_impresa="";
                String matriz[][]=new String[orden_filas][orden_columnas];
                int nro_random;

                for(int fila=0;fila<matriz.length;fila++){
                      for(int col=0;col<matriz[0].length;col++){
                          nro_random=(int)(Math.random()*(100-50+1)+50);
                          if(nro_random%2==0){
                              matriz[fila][col]="X";
                          }else{
                               matriz[fila][col]="O";
                          }
                          matriz_impresa+=matriz[fila][col]+" ";
                      }
                    matriz_impresa+="\n";
                  }
             
              
                for(int fila=0;fila<matriz.length;fila++){
                    
                    for(int col=0;col<matriz[0].length;col++){
                        nro_random=(int)(Math.random()*(100-50+1)+50);
                        if(matriz[fila][col].equals("X")){
                            vector_x[fila]++;
                        }else{
                             vector_o[fila]++;
                        }
                    }
                }
              
              for(int pos=0;pos<orden_filas;pos++){
                    vector_x_impreso+=vector_x[pos]+" - " ;
                    vector_o_impreso+=vector_o[pos]+" - ";
                }
              
               txt_retornar+="el vector con las X's es \n "+vector_x_impreso+" \n el vector con las O's es \n"+vector_o_impreso+"\n la matriz es: \n"+matriz_impresa;

              
              return txt_retornar;


            }
            catch (Exception e){
                return "error en Calcular_repetidos_matriz_vector";
            }
      }

    /*
     * 9. Llene una matriz de 5x5 con números aleatorios entre 1 y 9. En un vector
     * adicional, calcule la cantidad de números repetidos por cada fila y en otro
     * vector la cantidad de números repetidos de cada columna.
     */
         public static String Calcular_repetidos_matriz_vector(){
          try{
              int orden =5;
              String txt_retornar="",txt_filas="",txt_columnas="",txt_matriz="";
              int[] vector_repetidos_filas=new int[orden];
              int[] vector_repetidos_columnas=new int[orden];
              int nro_max_matriz=9;
              int nro_min_matriz=1;
              int matriz[][]=new int[orden][orden];
             
              

              for(int fila=0;fila<matriz.length;fila++){
                    for(int col=0;col<matriz[0].length;col++){
                        matriz[fila][col]=(int)(Math.random()*(nro_max_matriz-nro_min_matriz+1)+nro_min_matriz);
                        txt_matriz+=matriz[fila][col]+"\t";
                    }
                  txt_matriz+="\n";
                  
                }

              for(int fila=0;fila<matriz.length;fila++){
                  boolean[] repetidos_filas = new boolean[10];
                    for(int col=0;col<matriz[0].length;col++){
                        if (repetidos_filas[matriz[fila][col]]) {
                            vector_repetidos_filas[fila]++;
                        } else {
                            repetidos_filas[matriz[fila][col]] = true;
                        }
                    }
              }
              
              for(int col=0;col<matriz.length;col++){
                  boolean[] repetidos_columnas = new boolean[10];
                      for(int fila=0;fila<matriz.length;fila++){
                          if (repetidos_columnas[matriz[fila][col]]) {
                              vector_repetidos_columnas[col]++;
                          } else {
                              repetidos_columnas[matriz[fila][col]] = true;
                          }
                      }
                }
              
              for(int pos=0;pos<vector_repetidos_columnas.length;pos++){
                  txt_filas+=vector_repetidos_filas[pos]+"-";
                  txt_columnas+=vector_repetidos_columnas[pos]+"-";
                  
              }
              txt_retornar="la matriz es: \n"+txt_matriz+"\n el vector filas es : \n"+txt_filas+"\n el vector de columnas es: \n"+txt_columnas;

              return txt_retornar;
          }
          catch (Exception e){
              return "error en Calcular_repetidos_matriz_vector";
          }
          
      }

}
